# Next js 기초

## FoundAtions

Next.js 공식 튜토리얼을 공부하면서 모르는 부분과 중요한 부분 정리 해보기 !

### 1. Next js란

> Nextjs란 빠른 웹 어플리케이션을 만들기 위한 building block을 제공하는 프레임워크

프레임워크는 Next.js가 React에 필요한 도구와 구성을 처리하고, 어플리케이션에 대한 구조 및 기능, 최적화를 제공한다는 의미를 갖고 있다.

### 2. Javascript에서 React까지

사용자가 웹 페이지를 방문하게 되면 서버는 HTML 파일을 브라우저에게 제공하면 브라우저는 해당 HTML을 읽고 DOM을 구성한다. 여기서 DOM이란 HTML 요소의 객체 표현으로 직역하면 문서 객체 모델라고 한다.

> 문제. DOM을 조작해 페이지 내용을 업데이트 할 수 있을까?
>
> ##### 할수 있다.

위와 같은 DOM을 업데이트 하기 위해서는 javascript 및 DOM 메서드로 UI를 업데이트 할 수 있다.

여기서 명령형 VS 선언적 프로그래밍 이라는게 나오는데 명령형은 간단하게 말하자면 요리사에게 피자 만드는 방법에 대해 단계별로 지침을 제공 하는 것 이고 선언적은 단계는 걱정하지 않고 피자를 주문하는 것과 같다고 한다.

여기서 리액트는 선언적 프로그래밍에 해당한다. 그 이유는 React에게 원하는 UI 상태를 알려주면 DOM이 그 상태와 일치하도록 하기 때문에 사용할 때 비교 알고리즘 등의 내부 동작을 알 필요 없다고 한다.

---

JSX란 HTML와 유사한 구문으로 javascript를 확장한 문법이라고 생각하면 편하다. 브라우저는 JSX를 이해할 수 없기 때문에 JSX 코드를 일반 javascript로 변환하는 과정을 거친다.

> 따라서 바벨과 같은 Javascript 컴파일러가 필요.

---

React에서 Props란 components에 정보를 제공하기 위해 사용된다. 또한 jsx에서 `array.map`을 사용하는 방법은 다음과 같다.

```jsx
<ul>
  {names.map((name) => (
    <li>{name}</li>
  ))}
</ul>
```

Props와 State의 차이점은 Props는 components에 전달되는 정보라면 상태는 일반적으로 사용자의 상호 작용에 의해 시간이 지남에따라 변경될 수 있는 정보이다.

### 3. React에서 Next로

> Next 파일 만드는 방법과 어떻게 공부해야되는지에 대한 설명 (정리할만한 부분 없음)

### 4. Next.js 작동 방식

환경은 코드가 실행 중인 컨텍스트라고 할 수 있다.

Next.js는 개발자와 애플리케이션 구축 경험을 최적화 한다.

> Typescript 및 ESlint 통합, Fast Refrash와 같은 개발자 환경을 개선한다.

프로덕션 단계에서 Next.js는 사용자와 애플리케이션의 사용 경험을 최적화한다.

환경마다 고려사항과 목표가 다르기 때문에 애플리케이션을 개발에서 운영으로 이동하기 위해 고려해야될 점이 많다.

> 컴파일, 번들, 최소화 및 코드 분할

Next.js는 이런 코드 변환과 인프라를 대부분 처리하여 애플리케이션을 프로덕션 환경으로 쉽게 전환할 수 있도록 지원한다.

이런 기능들을 처리할 수 있는 이유는 Next.js가 낮은 수준의 프로그래밍 언어인 Rust로 작성된 컴파일러와 compilation, minification, bundling 등에 사용할 수 있는 SWC를 가지고 있기 때문이라고 한다.

---

##### 컴파일

개발자는 JSX, javascript, typescript와 같이 개발자에게 친숙한 언어로 코드를 작성한다. 이러한 언어들은 개발자의 작업 속도를 향상 시키지만 브라우저 단에서 코드를 이해하기 위해서는 `컴파일`을 걸쳐야 한다.

#### 축소

개발자는 사람의 가독성에 최적한 코드를 작성한다. 이 코드에는 주석, 공백, 들여쓰기 및 코드가 실행되는데 필요없는 정보가 들어가게 된다. 이때 축소를 통해 코드의 기능은 변경하지는 않되, 불필요한 코드와 서식을 제거한다.

#### 번들링

개발자는 애플리케이션을 개발할때 module을 각 기능에 맞춰 나누어 개발한다. 이러한 모듈과 여러 패키지들을 내보내고 가져오면 복잡한 파일 종속성을 갖게된다.

번들링은 이러한 종속성 그래프를 해결하고 파일 수를 줄여 사용자가 웹 페이지를 방문할 때 파일에 대한 요청 수를 줄이는 것을 목표로 한다.

#### 코드 분할

기본적으로 Next.js는 JavaScript를 각 경로에 대해 별도의 청크로 분할한다. 사용자가 애플리케이션을 로드하면 Next.js는 초기 경로에 필요한 코드만 전송한다. 사용자가 애플리케이션을 탐색할 때 다른 경로와 연결된 청크를 가져온다. 이렇게 필요한 코드만 로드하면 애플리케이션의 초기 로딩 속도를 개선할 수 있다.

#### 빌드 시간 vs 런타임

빌드 시간(빌드 단계)은 프로덕션용 애플리케이션 코드를 준비하는 일련의 단계에 지정된 이름이다.

런타임(요청 시간)은 애플리케이션이 빌드 및 배포된 후 사용자의 요청에 대한 응답으로 애플리케이션이 실행되는 기간을 나타낸다.

#### 클라이언트 및 서버

클라이언트는 요청을 서버에 보내는 사용자 장치의 브라우저를 나타낸다. 그런 다음 서버에서 받은 응답을 사용자가 상호 작용할 수 있는 인터페이스로 바꾼다.

서버 는 애플리케이션 코드를 저장하고, 클라이언트로부터 요청을 수신하고, 일부 계산을 수행하고, 적절한 응답을 다시 보내는 데이터 센터의 컴퓨터를 나타낸다.

#### 렌더링

React에서 작성한 코드를 UI의 HTML 표현으로 변환하는 데 피할수 없는 작업이 있다. 이 프로세스를 `렌더링`이라고 한다.

Next.js에서는 서버 사이드 렌더링과 클라이언트 사이드 렌더링을 제공하고 있다.

> SSR이란 서버사이드 렌더링의 약자로 서버로부터 완전하게 만들어진 html파일을 받아와 페이지 전체를 렌더링 하는 방식이다. 먼저 클라이언트가 초기 화면을 로드하기위해 서버에 요청을 보낸다. 그럼 서버는 화면에 표시하는데 필요한 데이터를 얻어와 모두 삽입하고 css까지 모두 적용해서 렌더링 준비를 마친 HTML과 JS코드를 브라우저에 응답으로 전달한다. 브라우저에서는 바로 전달 받은 페이지를 띄운다. 이어, 브라우저가 JS 코드를 다운로드하고 html에 실행시킨다.

> CSR은 사용자의 요청에 따라 필요한 부분만 응답 받아 렌더링 하는 방식이다. CSR의 과정은 다음과 같다. 먼저 클라이언트에서 초기화면을 로드하기 위해 서버에 요청을 보낸다. 그럼 서버는 화면에 표시하는 데 필요한 완전한 리소스의 응답한다. 그런데 여기서 클라이언트 사이드 렌더링 방식이 서버사이드 렌더링 방식과 다른 점은 모든 js 파일을 다운받아 하기 때문에 초기 로딩 시간의 더 오래 걸린다는 점이다.
